classdef Network < handle

    % NETWORK è la classe che si occupa di definire la strutture della rete di Jackson 
    % che si vuole modellare a partire dalle informazioni passate in input 
    % dall'uttilizzatore della libreria. La struttura è composta di nodi di
    % cui la definicione è un compito del costruttore di questa classe.
    
    properties
        nodi
        matrice_di_adiacenza
    end
    
    methods

        % Costruttore
        function self = Network(distr_arrivo, distr_servizio, matrice_di_adicenza)

            % INPUT:
            % - distr_arrivo sarà una struttura di dimensione (num_nodi) x 1 in cui in
            %   ogni riga sarà memorizzata la distribuzione che regola gli
            %   arrivi dall'esterno per il relativo nodo;
            % - distr_servizio sarà una struttura di dimensione (num_nodi)x(num_server_max)
            %   in cui si vanno a memorizzare le distribuzioni che regolano
            %   i tempi di processo per ogni server di un nodo
            %   ATTENZIONE: Essendo che due nodi possono avere un numero di
            %   server diversi, la seconda dimensione di questa matrice è
            %   determinata a partire dal numero massimo di server che un
            %   nodo può avere. Per convenzione, se un nodo ha un numero di
            %   server minore del numero di colonne, la relativa riga sarà
            %   completata con dei NaN.
            % - matrice_di_adicenza è una matrice contentente elementi che
            %   sono tutti compresi tra [0,1] e dei function handle che mi
            %   permettono di fare degli switch (dipendenti da degli
            %   attributi del customer) e quindi selezionare dei nodi

            % Validazione della matrice di adiacenza
            if ~ismatrix(matrice_di_adicenza) 
               error('al costruttore non è stata passata una matrice');
            end
            if ~(size(matrice_di_adicenza,1) == size(matrice_di_adicenza,2))
                error('la matrice di adiacenza non è quadrata')
            end

            matrice_senza_FH = Sostituisci_ai_function_handle(matrice_di_adicenza);

            addpath('funzioni')

            if ~(Verifica_matrice_stocastica(matrice_senza_FH)) % verifica stocasticità
                error('la matrice non è stocastica')
            end

            posizione_sink = Trova_sink(matrice_senza_FH);
            
            if (lenght(posizione_sink) ~= 1)  % verifica che c'è un solo sink
                error('Più uscite nel sistema')
            end

            % verifica che non ci sono componenti connesse che non
            % convergono nel sink

            for i = 1:size(matrice_senza_FH,1)
                nodi_raggiungibili = Breadth
            end

            % OUTPUT:
            % A partire da queste info si va a definire una lista di nodi

            self.matrice_di_adiacenza = matrice_di_adicenza;
            self.distr_arrivo = distr_arrivo; % matrice di dimensione (num_nodi)x1
            self.distr_servizio = distr_servizio; % matrice di dimensione (num_nodi)x(num_server_max)
            self.nodi = {}; % lista che sarà riempita con istanze di Node
        end

        function new_matrix = Sostituisci_ai_function_handle(matrix)

            % è un metodo interno che consente di creare una matrice senza
            % function handle per verificare che la struttura della matrice
            % sia giusta 

            dim = size(matrix,1);
            new_matrix = zeros(dim,dim);

            for i=1:dim

                isFunction = cellfun(@(x) isa(x, 'function_handle'), matrix(i, :)); % mi restituisce un vettore di uni dove c'è il function handle
                nFunction = sum(isFunction); % numero di function handle sulla riga

                valore_sostitutivo = (nFunction > 0) * (1 / nFunction);

                for j = 1:nC
                    if isFunc(j)
                        new_matrix(i, j) = valore_sostitutivo;
                    else
                        new_matrix(i, j) = matrix{i, j};
                    end
                end

            end

        end
        function posizione = Trova_sink(matrix)

            % questa funzione trova il sink ( da dove escono i clienti )
            % nella matrice stocastica senza function handle

            diagonale = diag(matrix);
            posizione = find(diagonale == 1);    % trova l'elemento = 1 sulla diagonale 

        end
    end
end

